# 注意事项

1. 内部使用了 tids、tmp_mem 等符号, 可能与 使用该库的代码中的符号存在冲突, (等待线程库开发完成后加前缀解决)

## 请使用指针

2. 注意数组，请使用指针！编译器编译后可以看到: 数组和指针的访问方式是不一样的！浅拷贝真的很好用！

请看 test/thrd1.c

## 未定义行为

请看 test/b.c、test/c.c、test/d.c

```c
int _arr[10] = { 0 };
int* arr = _arr;

int ret1 = thrd_create(1);
if (ret1 == 0) { // 主线程
	arr[ret1] = 2;
	int ret2 = thrd_create(1);
	if (ret2 == 0) { // 主线程
		arr[ret2] = 5;
	} else {
		arr[ret2] = 7;
	}

} else { // 子线程 tid = 1
	arr[ret1] = 3;
	int ret2 = thrd_create(1);
	if (ret2 == 1) { // 子线程
		arr[ret2] = 11;
	} else {
		arr[ret2] = 13;
	}
}

thrd_join();
```

这是未定义行为。解释一下：thrd_join 会根据 当前的线程数量决定是否阻塞，
并且我们这里还会有 tid 的复用（因为 tid 是根据 线程数量 确定的）。
因此会出现一种情况，子线程 tid = 1 执行完了 --> thrd_join() ，cnt--，
然后导致 主线程的 if 分支中 thrd_create 创建出来的 tid=1，导致数据被复写了。

为什么会发生未定义：不能保证 子线程 thrd_join 与 父线程再次 thrd_create 的次序
